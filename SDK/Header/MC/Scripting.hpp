// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#define AUTO_GENERATED
#include "../Global.h"

#define BEFORE_EXTRA
// Include Headers or Declare Types Here

#undef BEFORE_EXTRA

namespace Scripting {

#define AFTER_EXTRA
// Add Member There
template <typename T0>
class Result {
public:
    Result() = delete;
    Result(Result const&) = delete;
    Result(Result const&&) = delete;
};
class ContextUserData {
public:
    ContextUserData() = delete;
    ContextUserData(ContextUserData const&) = delete;
    ContextUserData(ContextUserData const&&) = delete;
};
class ModuleBindingBuilder {
public:
    ModuleBindingBuilder() = delete;
    ModuleBindingBuilder(ModuleBindingBuilder const&) = delete;
    ModuleBindingBuilder(ModuleBindingBuilder const&&) = delete;
};
struct Error {
    Error() = delete;
    Error(Error const&) = delete;
    Error(Error const&&) = delete;
};
struct ArrayProxy {
    ArrayProxy() = delete;
    ArrayProxy(ArrayProxy const&) = delete;
    ArrayProxy(ArrayProxy const&&) = delete;
};
class StrongObjectHandle {
public:
    StrongObjectHandle() = delete;
    StrongObjectHandle(StrongObjectHandle const&) = delete;
    StrongObjectHandle(StrongObjectHandle const&&) = delete;
};
class WeakObjectHandle {
public:
    WeakObjectHandle() = delete;
    WeakObjectHandle(WeakObjectHandle const&) = delete;
    WeakObjectHandle(WeakObjectHandle const&&) = delete;
};
template <typename T0>
class WeakTypedObjectHandle {
public:
    WeakTypedObjectHandle() = delete;
    WeakTypedObjectHandle(WeakTypedObjectHandle const&) = delete;
    WeakTypedObjectHandle(WeakTypedObjectHandle const&&) = delete;
};
template <typename T0>
class ClassBindingBuilder {
public:
    ClassBindingBuilder() = delete;
    ClassBindingBuilder(ClassBindingBuilder const&) = delete;
    ClassBindingBuilder(ClassBindingBuilder const&&) = delete;
};
struct JSON {
    JSON() = delete;
    JSON(JSON const&) = delete;
    JSON(JSON const&&) = delete;
};
class LifetimeRegistry {
public:
    LifetimeRegistry() = delete;
    LifetimeRegistry(LifetimeRegistry const&) = delete;
    LifetimeRegistry(LifetimeRegistry const&&) = delete;
};
class ScriptObjectFactory {
public:
    ScriptObjectFactory() = delete;
    ScriptObjectFactory(ScriptObjectFactory const&) = delete;
    ScriptObjectFactory(ScriptObjectFactory const&&) = delete;
};
template <typename T0>
class StrongTypedObjectHandle {
public:
    StrongTypedObjectHandle() = delete;
    StrongTypedObjectHandle(StrongTypedObjectHandle const&) = delete;
    StrongTypedObjectHandle(StrongTypedObjectHandle const&&) = delete;
};
struct ModuleDescriptor {
    ModuleDescriptor() = delete;
    ModuleDescriptor(ModuleDescriptor const&) = delete;
    ModuleDescriptor(ModuleDescriptor const&&) = delete;
};
struct PropertyGetSet {
    PropertyGetSet() = delete;
    PropertyGetSet(PropertyGetSet const&) = delete;
    PropertyGetSet(PropertyGetSet const&&) = delete;
};
struct ContextId {
    ContextId() = delete;
    ContextId(ContextId const&) = delete;
    ContextId(ContextId const&&) = delete;
};
struct ObjectHandle {
    ObjectHandle() = delete;
    ObjectHandle(ObjectHandle const&) = delete;
    ObjectHandle(ObjectHandle const&&) = delete;
};
class WeakLifetimeScope {
public:
    WeakLifetimeScope() = delete;
    WeakLifetimeScope(WeakLifetimeScope const&) = delete;
    WeakLifetimeScope(WeakLifetimeScope const&&) = delete;
};
class IRuntime {
public:
    IRuntime() = delete;
    IRuntime(IRuntime const&) = delete;
    IRuntime(IRuntime const&&) = delete;
};
template <typename T0>
class ScriptPromise {
public:
    ScriptPromise() = delete;
    ScriptPromise(ScriptPromise const&) = delete;
    ScriptPromise(ScriptPromise const&&) = delete;
};
class RuntimeUserData {
public:
    RuntimeUserData() = delete;
    RuntimeUserData(RuntimeUserData const&) = delete;
    RuntimeUserData(RuntimeUserData const&&) = delete;
};
struct Version {
    Version() = delete;
    Version(Version const&) = delete;
    Version(Version const&&) = delete;
};
struct ScriptContextResult {
    ScriptContextResult() = delete;
    ScriptContextResult(ScriptContextResult const&) = delete;
    ScriptContextResult(ScriptContextResult const&&) = delete;
};
class ResultAny {
public:
    ResultAny() = delete;
    ResultAny(ResultAny const&) = delete;
    ResultAny(ResultAny const&&) = delete;
};
namespace Reflection {
class IFunction {
public:
    IFunction() = delete;
    IFunction(IFunction const&) = delete;
    IFunction(IFunction const&&) = delete;
};
} // namespace Reflection

class IModuleBindingFactory {
public:
    IModuleBindingFactory() = delete;
    IModuleBindingFactory(IModuleBindingFactory const&) = delete;
    IModuleBindingFactory(IModuleBindingFactory const&&) = delete;
};
template <typename T0>
class TypedScriptClosure {
public:
    TypedScriptClosure() = delete;
    TypedScriptClosure(TypedScriptClosure const&) = delete;
    TypedScriptClosure(TypedScriptClosure const&&) = delete;
};
class IDebuggerController {
public:
    IDebuggerController() = delete;
    IDebuggerController(IDebuggerController const&) = delete;
    IDebuggerController(IDebuggerController const&&) = delete;
};
template <typename T0>
struct TypedObjectHandle {
    TypedObjectHandle() = delete;
    TypedObjectHandle(TypedObjectHandle const&) = delete;
    TypedObjectHandle(TypedObjectHandle const&&) = delete;
};
enum HandleReference;

#undef AFTER_EXTRA
    MCAPI struct JSValue ConvertJSValueArgsToNativeAnys(struct JSContext*, class Scripting::Reflection::IFunction*, unsigned int, struct JSValue*, class std::array<class entt::meta_any, 16>&, unsigned int);
    MCAPI struct JSValue CopyJSValueArrayToNativeSequenceContainer(struct JSContext*, struct JSValue, class entt::meta_sequence_container&);
    MCAPI struct Scripting::ArrayProxy CreateArrayProxy(struct JSContext*);
    MCAPI std::string ExceptionWriter(struct JSContext*);
    MCAPI struct JSValue GenericFreeFunctionCaller(struct JSContext*, struct JSValue, int, struct JSValue*, int, struct JSValue*);
    MCAPI struct JSValue GenericObjectFunctionCaller(struct JSContext*, struct JSValue, int, struct JSValue*, int, struct JSValue*);
    MCAPI struct JSValue GenericReflectionCtorCaller(struct JSContext*, struct JSValue, int, struct JSValue*, int);
    MCAPI struct JSValue GenericReflectionPropertyGetter(struct JSContext*, struct JSValue, int, struct JSValue*, int, struct JSValue*);
    MCAPI struct JSValue GenericReflectionPropertySetter(struct JSContext*, struct JSValue, int, struct JSValue*, int, struct JSValue*);
    MCAPI class Scripting::ContextUserData* GetContextUserData(struct JSContext*);
    MCAPI class Scripting::Reflection::IFunction* GetFunctionFromJSFuncData(struct JSContext*, struct JSValue*);
    MCAPI unsigned int GetJSArrayLength(struct JSContext*, struct JSValue);
    MCAPI std::string GetModuleName(struct JSContext*, struct JSModuleDef*);
    MCAPI struct Scripting::ObjectHandle GetNativeObjectHandleFromJSValue(struct JSValue);
    MCAPI struct Scripting::PropertyGetSet GetPropertyGetSetFromJSFuncData(struct JSContext*, struct JSValue*);
    MCAPI class Scripting::RuntimeUserData* GetRuntimeUserData(struct JSRuntime*);
    MCAPI bool HasBaseType(class entt::meta_type, class entt::meta_type);
    MCAPI bool HasNativeObjectHandle(struct JSValue);
    MCAPI class std::variant<class entt::meta_any, struct JSValue> JSValueToNativeAny(struct JSContext*, struct JSValue, class entt::meta_type);
    MCAPI struct JSValue NativeAnyToJSValue(struct JSContext*, class entt::meta_any&, bool, bool);
    MCAPI struct JSValue NativeObjectHandleToJSValue(struct JSContext*, struct Scripting::ObjectHandle, bool, enum Scripting::HandleReference);
    MCAPI void SetNativeObjectHandleToJSValue(struct Scripting::ObjectHandle, struct JSValue);

};